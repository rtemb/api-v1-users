// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"net/http"
	"sync"

	"github.com/grpc-ecosystem/grpc-gateway/runtime"
	"github.com/rtemb/api-v1-users/internal/middleware"
)

type AppMiddlewareMock struct {
	AuthorizationStub        func(http.Handler) http.Handler
	authorizationMutex       sync.RWMutex
	authorizationArgsForCall []struct {
		arg1 http.Handler
	}
	authorizationReturns struct {
		result1 http.Handler
	}
	authorizationReturnsOnCall map[int]struct {
		result1 http.Handler
	}
	CORSProtectionStub        func(http.Handler) http.Handler
	cORSProtectionMutex       sync.RWMutex
	cORSProtectionArgsForCall []struct {
		arg1 http.Handler
	}
	cORSProtectionReturns struct {
		result1 http.Handler
	}
	cORSProtectionReturnsOnCall map[int]struct {
		result1 http.Handler
	}
	LogRequestsStub        func(http.Handler) http.Handler
	logRequestsMutex       sync.RWMutex
	logRequestsArgsForCall []struct {
		arg1 http.Handler
	}
	logRequestsReturns struct {
		result1 http.Handler
	}
	logRequestsReturnsOnCall map[int]struct {
		result1 http.Handler
	}
	ReadinesslivenessProbeStub        func(http.Handler) http.Handler
	readinesslivenessProbeMutex       sync.RWMutex
	readinesslivenessProbeArgsForCall []struct {
		arg1 http.Handler
	}
	readinesslivenessProbeReturns struct {
		result1 http.Handler
	}
	readinesslivenessProbeReturnsOnCall map[int]struct {
		result1 http.Handler
	}
	SetupMiddlewareStub        func(*runtime.ServeMux) *http.ServeMux
	setupMiddlewareMutex       sync.RWMutex
	setupMiddlewareArgsForCall []struct {
		arg1 *runtime.ServeMux
	}
	setupMiddlewareReturns struct {
		result1 *http.ServeMux
	}
	setupMiddlewareReturnsOnCall map[int]struct {
		result1 *http.ServeMux
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *AppMiddlewareMock) Authorization(arg1 http.Handler) http.Handler {
	fake.authorizationMutex.Lock()
	ret, specificReturn := fake.authorizationReturnsOnCall[len(fake.authorizationArgsForCall)]
	fake.authorizationArgsForCall = append(fake.authorizationArgsForCall, struct {
		arg1 http.Handler
	}{arg1})
	fake.recordInvocation("Authorization", []interface{}{arg1})
	fake.authorizationMutex.Unlock()
	if fake.AuthorizationStub != nil {
		return fake.AuthorizationStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.authorizationReturns
	return fakeReturns.result1
}

func (fake *AppMiddlewareMock) AuthorizationCallCount() int {
	fake.authorizationMutex.RLock()
	defer fake.authorizationMutex.RUnlock()
	return len(fake.authorizationArgsForCall)
}

func (fake *AppMiddlewareMock) AuthorizationCalls(stub func(http.Handler) http.Handler) {
	fake.authorizationMutex.Lock()
	defer fake.authorizationMutex.Unlock()
	fake.AuthorizationStub = stub
}

func (fake *AppMiddlewareMock) AuthorizationArgsForCall(i int) http.Handler {
	fake.authorizationMutex.RLock()
	defer fake.authorizationMutex.RUnlock()
	argsForCall := fake.authorizationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *AppMiddlewareMock) AuthorizationReturns(result1 http.Handler) {
	fake.authorizationMutex.Lock()
	defer fake.authorizationMutex.Unlock()
	fake.AuthorizationStub = nil
	fake.authorizationReturns = struct {
		result1 http.Handler
	}{result1}
}

func (fake *AppMiddlewareMock) AuthorizationReturnsOnCall(i int, result1 http.Handler) {
	fake.authorizationMutex.Lock()
	defer fake.authorizationMutex.Unlock()
	fake.AuthorizationStub = nil
	if fake.authorizationReturnsOnCall == nil {
		fake.authorizationReturnsOnCall = make(map[int]struct {
			result1 http.Handler
		})
	}
	fake.authorizationReturnsOnCall[i] = struct {
		result1 http.Handler
	}{result1}
}

func (fake *AppMiddlewareMock) CORSProtection(arg1 http.Handler) http.Handler {
	fake.cORSProtectionMutex.Lock()
	ret, specificReturn := fake.cORSProtectionReturnsOnCall[len(fake.cORSProtectionArgsForCall)]
	fake.cORSProtectionArgsForCall = append(fake.cORSProtectionArgsForCall, struct {
		arg1 http.Handler
	}{arg1})
	fake.recordInvocation("CORSProtection", []interface{}{arg1})
	fake.cORSProtectionMutex.Unlock()
	if fake.CORSProtectionStub != nil {
		return fake.CORSProtectionStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.cORSProtectionReturns
	return fakeReturns.result1
}

func (fake *AppMiddlewareMock) CORSProtectionCallCount() int {
	fake.cORSProtectionMutex.RLock()
	defer fake.cORSProtectionMutex.RUnlock()
	return len(fake.cORSProtectionArgsForCall)
}

func (fake *AppMiddlewareMock) CORSProtectionCalls(stub func(http.Handler) http.Handler) {
	fake.cORSProtectionMutex.Lock()
	defer fake.cORSProtectionMutex.Unlock()
	fake.CORSProtectionStub = stub
}

func (fake *AppMiddlewareMock) CORSProtectionArgsForCall(i int) http.Handler {
	fake.cORSProtectionMutex.RLock()
	defer fake.cORSProtectionMutex.RUnlock()
	argsForCall := fake.cORSProtectionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *AppMiddlewareMock) CORSProtectionReturns(result1 http.Handler) {
	fake.cORSProtectionMutex.Lock()
	defer fake.cORSProtectionMutex.Unlock()
	fake.CORSProtectionStub = nil
	fake.cORSProtectionReturns = struct {
		result1 http.Handler
	}{result1}
}

func (fake *AppMiddlewareMock) CORSProtectionReturnsOnCall(i int, result1 http.Handler) {
	fake.cORSProtectionMutex.Lock()
	defer fake.cORSProtectionMutex.Unlock()
	fake.CORSProtectionStub = nil
	if fake.cORSProtectionReturnsOnCall == nil {
		fake.cORSProtectionReturnsOnCall = make(map[int]struct {
			result1 http.Handler
		})
	}
	fake.cORSProtectionReturnsOnCall[i] = struct {
		result1 http.Handler
	}{result1}
}

func (fake *AppMiddlewareMock) LogRequests(arg1 http.Handler) http.Handler {
	fake.logRequestsMutex.Lock()
	ret, specificReturn := fake.logRequestsReturnsOnCall[len(fake.logRequestsArgsForCall)]
	fake.logRequestsArgsForCall = append(fake.logRequestsArgsForCall, struct {
		arg1 http.Handler
	}{arg1})
	fake.recordInvocation("LogRequests", []interface{}{arg1})
	fake.logRequestsMutex.Unlock()
	if fake.LogRequestsStub != nil {
		return fake.LogRequestsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.logRequestsReturns
	return fakeReturns.result1
}

func (fake *AppMiddlewareMock) LogRequestsCallCount() int {
	fake.logRequestsMutex.RLock()
	defer fake.logRequestsMutex.RUnlock()
	return len(fake.logRequestsArgsForCall)
}

func (fake *AppMiddlewareMock) LogRequestsCalls(stub func(http.Handler) http.Handler) {
	fake.logRequestsMutex.Lock()
	defer fake.logRequestsMutex.Unlock()
	fake.LogRequestsStub = stub
}

func (fake *AppMiddlewareMock) LogRequestsArgsForCall(i int) http.Handler {
	fake.logRequestsMutex.RLock()
	defer fake.logRequestsMutex.RUnlock()
	argsForCall := fake.logRequestsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *AppMiddlewareMock) LogRequestsReturns(result1 http.Handler) {
	fake.logRequestsMutex.Lock()
	defer fake.logRequestsMutex.Unlock()
	fake.LogRequestsStub = nil
	fake.logRequestsReturns = struct {
		result1 http.Handler
	}{result1}
}

func (fake *AppMiddlewareMock) LogRequestsReturnsOnCall(i int, result1 http.Handler) {
	fake.logRequestsMutex.Lock()
	defer fake.logRequestsMutex.Unlock()
	fake.LogRequestsStub = nil
	if fake.logRequestsReturnsOnCall == nil {
		fake.logRequestsReturnsOnCall = make(map[int]struct {
			result1 http.Handler
		})
	}
	fake.logRequestsReturnsOnCall[i] = struct {
		result1 http.Handler
	}{result1}
}

func (fake *AppMiddlewareMock) ReadinesslivenessProbe(arg1 http.Handler) http.Handler {
	fake.readinesslivenessProbeMutex.Lock()
	ret, specificReturn := fake.readinesslivenessProbeReturnsOnCall[len(fake.readinesslivenessProbeArgsForCall)]
	fake.readinesslivenessProbeArgsForCall = append(fake.readinesslivenessProbeArgsForCall, struct {
		arg1 http.Handler
	}{arg1})
	fake.recordInvocation("ReadinesslivenessProbe", []interface{}{arg1})
	fake.readinesslivenessProbeMutex.Unlock()
	if fake.ReadinesslivenessProbeStub != nil {
		return fake.ReadinesslivenessProbeStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.readinesslivenessProbeReturns
	return fakeReturns.result1
}

func (fake *AppMiddlewareMock) ReadinesslivenessProbeCallCount() int {
	fake.readinesslivenessProbeMutex.RLock()
	defer fake.readinesslivenessProbeMutex.RUnlock()
	return len(fake.readinesslivenessProbeArgsForCall)
}

func (fake *AppMiddlewareMock) ReadinesslivenessProbeCalls(stub func(http.Handler) http.Handler) {
	fake.readinesslivenessProbeMutex.Lock()
	defer fake.readinesslivenessProbeMutex.Unlock()
	fake.ReadinesslivenessProbeStub = stub
}

func (fake *AppMiddlewareMock) ReadinesslivenessProbeArgsForCall(i int) http.Handler {
	fake.readinesslivenessProbeMutex.RLock()
	defer fake.readinesslivenessProbeMutex.RUnlock()
	argsForCall := fake.readinesslivenessProbeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *AppMiddlewareMock) ReadinesslivenessProbeReturns(result1 http.Handler) {
	fake.readinesslivenessProbeMutex.Lock()
	defer fake.readinesslivenessProbeMutex.Unlock()
	fake.ReadinesslivenessProbeStub = nil
	fake.readinesslivenessProbeReturns = struct {
		result1 http.Handler
	}{result1}
}

func (fake *AppMiddlewareMock) ReadinesslivenessProbeReturnsOnCall(i int, result1 http.Handler) {
	fake.readinesslivenessProbeMutex.Lock()
	defer fake.readinesslivenessProbeMutex.Unlock()
	fake.ReadinesslivenessProbeStub = nil
	if fake.readinesslivenessProbeReturnsOnCall == nil {
		fake.readinesslivenessProbeReturnsOnCall = make(map[int]struct {
			result1 http.Handler
		})
	}
	fake.readinesslivenessProbeReturnsOnCall[i] = struct {
		result1 http.Handler
	}{result1}
}

func (fake *AppMiddlewareMock) SetupMiddleware(arg1 *runtime.ServeMux) *http.ServeMux {
	fake.setupMiddlewareMutex.Lock()
	ret, specificReturn := fake.setupMiddlewareReturnsOnCall[len(fake.setupMiddlewareArgsForCall)]
	fake.setupMiddlewareArgsForCall = append(fake.setupMiddlewareArgsForCall, struct {
		arg1 *runtime.ServeMux
	}{arg1})
	fake.recordInvocation("SetupMiddleware", []interface{}{arg1})
	fake.setupMiddlewareMutex.Unlock()
	if fake.SetupMiddlewareStub != nil {
		return fake.SetupMiddlewareStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.setupMiddlewareReturns
	return fakeReturns.result1
}

func (fake *AppMiddlewareMock) SetupMiddlewareCallCount() int {
	fake.setupMiddlewareMutex.RLock()
	defer fake.setupMiddlewareMutex.RUnlock()
	return len(fake.setupMiddlewareArgsForCall)
}

func (fake *AppMiddlewareMock) SetupMiddlewareCalls(stub func(*runtime.ServeMux) *http.ServeMux) {
	fake.setupMiddlewareMutex.Lock()
	defer fake.setupMiddlewareMutex.Unlock()
	fake.SetupMiddlewareStub = stub
}

func (fake *AppMiddlewareMock) SetupMiddlewareArgsForCall(i int) *runtime.ServeMux {
	fake.setupMiddlewareMutex.RLock()
	defer fake.setupMiddlewareMutex.RUnlock()
	argsForCall := fake.setupMiddlewareArgsForCall[i]
	return argsForCall.arg1
}

func (fake *AppMiddlewareMock) SetupMiddlewareReturns(result1 *http.ServeMux) {
	fake.setupMiddlewareMutex.Lock()
	defer fake.setupMiddlewareMutex.Unlock()
	fake.SetupMiddlewareStub = nil
	fake.setupMiddlewareReturns = struct {
		result1 *http.ServeMux
	}{result1}
}

func (fake *AppMiddlewareMock) SetupMiddlewareReturnsOnCall(i int, result1 *http.ServeMux) {
	fake.setupMiddlewareMutex.Lock()
	defer fake.setupMiddlewareMutex.Unlock()
	fake.SetupMiddlewareStub = nil
	if fake.setupMiddlewareReturnsOnCall == nil {
		fake.setupMiddlewareReturnsOnCall = make(map[int]struct {
			result1 *http.ServeMux
		})
	}
	fake.setupMiddlewareReturnsOnCall[i] = struct {
		result1 *http.ServeMux
	}{result1}
}

func (fake *AppMiddlewareMock) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.authorizationMutex.RLock()
	defer fake.authorizationMutex.RUnlock()
	fake.cORSProtectionMutex.RLock()
	defer fake.cORSProtectionMutex.RUnlock()
	fake.logRequestsMutex.RLock()
	defer fake.logRequestsMutex.RUnlock()
	fake.readinesslivenessProbeMutex.RLock()
	defer fake.readinesslivenessProbeMutex.RUnlock()
	fake.setupMiddlewareMutex.RLock()
	defer fake.setupMiddlewareMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *AppMiddlewareMock) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ middleware.AppMiddleware = new(AppMiddlewareMock)
